<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="引言此文是iOS中的多线程编程：重温GCD（一）系列的第二部分。将会辅以一定的例子讲解一些更深层次的API使用及注意事项。">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS中的多线程编程：重温GCD（二）">
<meta property="og:url" content="http://yoursite.com/2016/08/26/iOS中的多线程编程：重温GCD（二）/index.html">
<meta property="og:site_name" content="🐰BiuBiuBiu~">
<meta property="og:description" content="引言此文是iOS中的多线程编程：重温GCD（一）系列的第二部分。将会辅以一定的例子讲解一些更深层次的API使用及注意事项。">
<meta property="og:image" content="http://i2.buimg.com/572363/3af4576fb2897c06.png">
<meta property="og:image" content="http://i2.buimg.com/572363/a0cc83549bcc31a1.png">
<meta property="og:updated_time" content="2016-08-28T09:33:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS中的多线程编程：重温GCD（二）">
<meta name="twitter:description" content="引言此文是iOS中的多线程编程：重温GCD（一）系列的第二部分。将会辅以一定的例子讲解一些更深层次的API使用及注意事项。">
<meta name="twitter:image" content="http://i2.buimg.com/572363/3af4576fb2897c06.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Zheng Li'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/08/26/iOS中的多线程编程：重温GCD（二）/"/>

  <title> iOS中的多线程编程：重温GCD（二） | 🐰BiuBiuBiu~ </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">🐰BiuBiuBiu~</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">记录自己学习的点点滴滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                iOS中的多线程编程：重温GCD（二）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-08-26T19:34:26+08:00" content="2016-08-26">
              2016-08-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/26/iOS中的多线程编程：重温GCD（二）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/26/iOS中的多线程编程：重温GCD（二）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/26/iOS中的多线程编程：重温GCD（二）/" class="leancloud_visitors" data-flag-title="iOS中的多线程编程：重温GCD（二）">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">visitors </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>此文是<a href="http://objc.in/2016/08/24/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%87%8D%E6%B8%A9GCD%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">iOS中的多线程编程：重温GCD（一）</a>系列的第二部分。将会辅以一定的例子讲解一些更深层次的<code>API</code>使用及注意事项。</p>
<a id="more"></a>
<h2 id="栅栏-Using-Barriers"><a href="#栅栏-Using-Barriers" class="headerlink" title="栅栏 | Using Barriers"></a>栅栏 | Using Barriers</h2><h3 id="使用barrier构建一个安全的读写操作"><a href="#使用barrier构建一个安全的读写操作" class="headerlink" title="使用barrier构建一个安全的读写操作"></a>使用<code>barrier</code>构建一个安全的读写操作</h3><p>在<a href="http://objc.in/2016/08/24/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%87%8D%E6%B8%A9GCD%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">上篇文章</a>中，我们最后提到了如何利用<code>GCD</code>创建线程安全的单例。但这其实是远远不够的。考虑这样一个问题：</p>
<p>如果我们的单粒中有这样的可变属性</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableArray</span> *array;`</div></pre></td></tr></table></figure>
<p>我们了解，在<code>objc</code>中，apple明确告诉我们这样的可变集合都<strong>不是线程安全</strong>的。这意味着，如果我们的单粒在多个线程中被读写，很容易就发生数据混乱的问题！</p>
<p><code>dispatch barrier</code>可以很好的解决这个问题！</p>
<p>根据apple官方文档：</p>
<blockquote>
<p>A dispatch barrier allows you to create a synchronization point within a concurrent dispatch queue. When it encounters a barrier, a concurrent queue delays the execution of the barrier block (or any further blocks) until all blocks submitted before the barrier finish executing. At that point, the barrier block executes by itself. Upon completion, the queue resumes its normal execution behavior.</p>
</blockquote>
<p>简单翻译下，可见<code>dispatch barrier</code>允许我们在一个并发队列中创建一个<strong>同步</strong>点，你也可以把它理解为一个任务(<code>block</code>)，当队列中的任务按序派发到这里时，并发队列会停下等待<code>barrier</code>点前面的所有任务执行完毕，接着执行<code>barrier block</code>。等<code>barrier block</code>执行完毕后继续执行后面的任务:</p>
<p><img src="http://i2.buimg.com/572363/3af4576fb2897c06.png" alt="barrier"></p>
<p>试想一下，如果我们在两个线程同时在操作这个数组，如果两个线程都在同时读取，那不会引起问题。如果一个线程中在读取，同时另外一个线程中在写入，就会引起线程不安全的问题！</p>
<p>所以我们应该不把这个属性暴露在外部，使得外部不能直接写入，而是提供给外部一些方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)add:(<span class="keyword">id</span>)object;</div><div class="line">- (<span class="keyword">void</span>)remove:(<span class="keyword">id</span>)object;</div></pre></td></tr></table></figure>
<p>然后，我们在内部利用<code>barrier</code>进行安全的写入：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)add:(<span class="keyword">id</span>)object&#123;</div><div class="line">	<span class="keyword">if</span>(!object) <span class="keyword">return</span>;</div><div class="line">	<span class="comment">//保证写入时，不会被队列中的异步操作"打扰"</span></div><div class="line">	dispatch_barrier_async(<span class="keyword">self</span>.concurrentQueue, ^&#123; </div><div class="line">	[<span class="keyword">self</span>.array addObject:object];</div><div class="line">	</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们就保证了在操作单例中数组的过程中，不会发生任何异步行为，也就保证了线程安全！</p>
<p>另外需要注意得地方是，我们在上述代码段里使用了<code>self.concurrentQueue</code>为什么我们会使用<code>self.concurrentQueue</code>?</p>
<p>首先要说明的是，<code>self.concurrentQueue</code>是一个自定义的并发队列，它的创建方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.concurrentQueue = dispatch_queue_create(<span class="string">"com.selander.GooglyPuff.photoQueue"</span>,</div><div class="line">                                                    DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<p>我们会将单粒中的读操作也放在这个队列里：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *) array</div><div class="line">&#123;</div><div class="line">    __block <span class="built_in">NSArray</span> *array; </div><div class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.concurrentQueue, ^&#123; </div><div class="line">        array = [<span class="built_in">NSArray</span> arrayWithArray:_photosArray]; </div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，才能保证在写操作时候拦住前面的读操作，因为它们都在用一个队列中。当然，<strong>这个地方必须使用<code>dispathc_sync</code>函数</strong>，如果异步调用意味着函数不会立即返回。那么在外部使用的得到的数组时就可能会出问题,比如:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableArray</span> *)array&#123;</div><div class="line">    </div><div class="line">     __block <span class="built_in">NSMutableArray</span> *tmpArray = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.concurrentQueue, ^&#123;</div><div class="line">        tmpArray = [_array <span class="keyword">copy</span>];<span class="comment">//注意这个地方可能在返回之前还没有调用！</span></div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> tmpArray;<span class="comment">//tmpArray可能为nil！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="barrier的API"><a href="#barrier的API" class="headerlink" title="barrier的API"></a><code>barrier</code>的<code>API</code></h3><p><code>barrier</code>是个很有用的特性，在apple的官方文档中，有列出了下列函数供我们使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> dispatch_barrier_async( <span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</div><div class="line"></div><div class="line"><span class="keyword">void</span> dispatch_barrier_async_f( <span class="built_in">dispatch_queue_t</span> queue, <span class="keyword">void</span>* context,dispatch_function_t work);</div><div class="line"></div><div class="line"><span class="keyword">void</span> dispatch_barrier_sync( <span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</div><div class="line"></div><div class="line"><span class="keyword">void</span> dispatch_barrier_sync_f( <span class="built_in">dispatch_queue_t</span> queue, <span class="keyword">void</span>* context, dispatch_function_t work);</div></pre></td></tr></table></figure>
<p>其实还是很有规律的😄：<code>async</code>与<code>sync</code>相对表示同步or异步、<code>async_f</code>与<code>sync</code>相对表示执行的是<code>block</code>或者<code>dispatch_function_t</code>对象。</p>
<p>由于篇幅有限，在这里就不在解释了。只给出结论: </p>
<ol>
<li><p>无论是<code>dispatch_barrier_sync</code>or <code>dispatch_barrier_async</code>函数，最终都会调用到<code>dispatch_barrier_sync_f</code>or<code>dispatch_barrier_async_f</code>。</p>
</li>
<li><p><code>dispatch_barrier_sync_f</code>函数中的<code>void* context</code>参数其实就是我们传给<code>dispatch_barrier_sync</code>函数中的<code>block</code>对象。而<code>dispatch_function_t work</code>参数是<code>block</code>对象里的函数指针(懂的人自然懂😄)。</p>
</li>
</ol>
<h3 id="barrier使用建议"><a href="#barrier使用建议" class="headerlink" title="barrier使用建议"></a><code>barrier</code>使用建议</h3><p>要理解<code>barrier</code>拦住的是队列，也就是说，<code>barrier</code>针对的队列。所以不难给出以下建议：</p>
<ol>
<li>不要在自定义串行队列中使用：一个很坏的选择，障碍不会有任何帮助，因为不管怎样，一个串行队列一次都只执行一个操作。</li>
<li>不要在全局并发队列中使用：要小心，这可能不是最好的主意，因为其它系统可能在使用队列而且你不能垄断它们只为你自己的目的。</li>
<li>最好在自定义并发队列中使用：这对于原子或临界区代码来说是极佳的选择。任何你在设置或实例化的需要线程安全的事物都是使用障碍的最佳候选。</li>
</ol>
<h3 id="barrier部分小结"><a href="#barrier部分小结" class="headerlink" title="barrier部分小结"></a><code>barrier</code>部分小结</h3><p><strong>todo 这里之后给出源码解读文章地址</strong>如果想要了解更多关于<code>barrier</code>的实现细节，可以查看我的这篇。当然你也可以自己下载<code>GCD</code>源码阅读：<a href="http://opensource.apple.com/tarballs/libdispatch/libdispatch-442.1.4.tar.gz" target="_blank" rel="external">libdispatch</a>。</p>
<h2 id="调度组-Dispatch-Groups"><a href="#调度组-Dispatch-Groups" class="headerlink" title="调度组 | Dispatch Groups"></a>调度组 | Dispatch Groups</h2><h3 id="使用Dispatch-Groups通知所有任务已经完成"><a href="#使用Dispatch-Groups通知所有任务已经完成" class="headerlink" title="使用Dispatch Groups通知所有任务已经完成"></a>使用Dispatch Groups通知所有任务已经完成</h3><p>与上文一样，我们会以一个例子开始来介绍<code>Dispatch Groups</code>的部分：</p>
<p>假设你要从网上下载许多张图片，完成之后把它们组合在一起构成新的图像。也就是说你必须把所有图片下载完成后再统一显示:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^block1)() = ^&#123;</div><div class="line">        <span class="comment">//download img_1 from network...</span></div><div class="line">    </div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">void</span> (^block2)() = ^&#123;</div><div class="line">        <span class="comment">//download img_2 from network...</span></div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">void</span> (^block3)() = ^&#123;</div><div class="line">        <span class="comment">//download img_2 from network...</span></div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), block1);</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), block2);</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), block3);</div><div class="line">    </div><div class="line">    <span class="comment">//拼接图片</span></div><div class="line">    [<span class="keyword">self</span> finishImg];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>这样写显然是有问题的！</strong><code>block1,block2,block3</code>的运行由于是在后台，我们无法确保拼接图片时所有图片已经下载完成。对于这种情况，<code>Dispatch Groups</code>就是个不错的选择：</p>
<h4 id="方法一：使用dispatch-group-notify"><a href="#方法一：使用dispatch-group-notify" class="headerlink" title="方法一：使用dispatch_group_notify"></a>方法一：使用<code>dispatch_group_notify</code></h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^block1)() = ^&#123;</div><div class="line">        <span class="comment">//download img1 from network...</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block1 finish"</span>);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^block2)() = ^&#123;</div><div class="line">        <span class="comment">//download img2 from network...</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block2 finish"</span>);</div><div class="line">   &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^block3)() = ^&#123;</div><div class="line">        <span class="comment">//download img3 from network...</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block3 finish"</span>);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line">    </div><div class="line">    dispatch_group_t downloadGroup = dispatch_group_create();</div><div class="line">    </div><div class="line">    dispatch_group_async(downloadGroup, queue, block1);</div><div class="line">    dispatch_group_async(downloadGroup, queue, block2);</div><div class="line">    dispatch_group_async(downloadGroup, queue, block3);</div><div class="line">    </div><div class="line">    dispatch_group_notify(downloadGroup, queue, ^&#123;</div><div class="line">        [<span class="keyword">self</span> finishImg];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)finishImg&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"finishi.."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，<code>finishImg</code>方法就会在三个block全部执行完毕后才被调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2016-08-27 15:12:37.885 总结测试[91285:7916599] block3 finish</div><div class="line">2016-08-27 15:12:37.885 总结测试[91285:7916593] block2 finish</div><div class="line">2016-08-27 15:12:37.885 总结测试[91285:7916604] block1 finish</div><div class="line">2016-08-27 15:12:37.886 总结测试[91285:7916604] finishi..</div></pre></td></tr></table></figure>
<p><code>dispatch_group_notify</code>函数非常灵活，它允许你在<code>group</code>内的任务全部完成后传递一个<code>block</code>作为回调。在上述的方法里，我们将图片拼接方法作为回调。</p>
<p>除了<code>dispatch_group_notify</code>函数，还有个<code>dispatch_group_t</code>字眼你可能会感到陌生，在苹果的官方文档中:</p>
<blockquote>
<p>A group of block objects submitted to a queue for asynchronous invocation.</p>
</blockquote>
<p><strong>Declaration</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dispatch_group_s *dispatch_group_t;</div></pre></td></tr></table></figure>
<p><strong>Discussion</strong></p>
<blockquote>
<p>A dispatch group is a mechanism for monitoring a set of blocks. Your application can monitor the blocks in the group synchronously or asynchronously depending on your needs. By extension, a group can be useful for synchronizing for code that depends on the completion of other tasks.</p>
<p>Note that the blocks in a group may be run on different queues, and each individual block can add more blocks to the group.</p>
<p>The dispatch group keeps track of how many blocks are outstanding, and GCD retains the group until all its associated blocks complete execution.</p>
</blockquote>
<p>可见<code>group</code>是异步<code>block</code>的集合。而<code>dispatch group</code>是一种监听这种集合的机制。苹果允许我们在同步或者异步的监听集合里的<code>block</code>完成的情况，而且需要注意到是，<code>group</code>内的<code>block</code>可能是在任何队列里的。就像我们上面的代码中写的那样:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_group_async(downloadGroup, queue, block1);</div><div class="line">dispatch_group_async(downloadGroup, queue, block2);</div><div class="line">dispatch_group_async(downloadGroup, queue, block3);</div></pre></td></tr></table></figure>
<p>我们可以提交<code>group</code>内的任务到任何<code>queue</code>内。</p>
<p>顺带一提的是，<code>gcd</code>会引用<code>group</code>对象直到任务都完成。</p>
<h4 id="方法二：使用dispatch-group-wait"><a href="#方法二：使用dispatch-group-wait" class="headerlink" title="方法二：使用dispatch_group_wait"></a>方法二：使用<code>dispatch_group_wait</code></h4><p><code>dispatch_group_wait</code>函数就像它的名字所叙述的那样：<strong>等待</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);</div></pre></td></tr></table></figure>
<p><code>dispatch_group_wait</code>函数会等待直到指定的<code>group</code>内的任务全部完成或者超时,从上方的申明我们可以看出，<code>dispatch_group_wait</code>与<code>dispatch_group_wait</code>函数一样都需要一个<code>group</code>参数，但是多了一个<code>timeout</code>替代<code>block</code>回调。同时，它还会有一个<code>long</code>型返回值。这个返回时标志了当前任务的执行情况或者是否超时：</p>
<blockquote>
<p><code>dispatch_group_wait</code> 会一直等待，直到任务全部完成或者超时。如果在所有任务完成前超时了，该函数会返回一个非零值。你可以对此返回值做条件判断以确定是否超出等待周期;当然，你可以在这里用 <code>DISPATCH_TIME_FOREVER</code> 让它永远等待。它的意思，勿庸置疑就是，永－远－等－待！于是我们只需要判断返回值是否为0就可以知道当前任务是否完成了。</p>
</blockquote>
<p>注意，一定要理解好<strong>等待</strong>。这意味着<code>dispatch_group_wait</code>会<strong>阻塞当前线程</strong>！另外，如果你不使用<code>DISPATCH_TIME_FOREVER</code>参数而是用<code>DISPATCH_TIME_NOW</code>，该函数会立即返回一个值给你，含义与<code>DISPATCH_TIME_FOREVER</code>一样。当然了，这样的话就不会阻塞当前线程了。但是需要像主线程里的<code>NSRunLoop</code>那样不停循环检测当前任务是否全部完成。</p>
<p>了解了<code>dispatch_group_wait</code>函数的含义，我们不难将第一种方法里的代码改写为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> grayColor];</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^block1)() = ^&#123;</div><div class="line">        <span class="comment">//download img1 from network...</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">500</span>;  i ++) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block1 finish  %d"</span>,i);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^block2)() = ^&#123;</div><div class="line">        <span class="comment">//download img2 from network...</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">500</span>;  i ++) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block2 finish  %d"</span>,i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^block3)() = ^&#123;</div><div class="line">        <span class="comment">//download img3 from network...</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">500</span>;  i ++) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block3 finish  %d"</span>,i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line">    </div><div class="line">    dispatch_group_t downloadGroup = dispatch_group_create();</div><div class="line">    </div><div class="line">    dispatch_group_async(downloadGroup, queue, block1);</div><div class="line">    dispatch_group_async(downloadGroup, queue, block2);</div><div class="line">    dispatch_group_async(downloadGroup, queue, block3);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="keyword">long</span> result =  dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER);</div><div class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [<span class="keyword">self</span> finishImg];</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要格外注意的是：由于<code>dispatch_group_wait</code>函数会阻塞当前线程，所以我们使用了<code>dispatch_async</code>函数以便能更快的使<code>viewDidLoad</code>方法结束以给予用户更好的体验。</p>
<h2 id="并行运行的for循环：dispatch-apply"><a href="#并行运行的for循环：dispatch-apply" class="headerlink" title="并行运行的for循环：dispatch_apply"></a>并行运行的<code>for</code>循环：<code>dispatch_apply</code></h2><p><code>dispatch_apply</code>函数会将<code>block</code>按指定的次数提交到指定的队列里去，之后等待所有任务完成后返回：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line"></div><div class="line">    dispatch_apply(<span class="number">10</span>, queue, ^(size_t x) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zu current thead == %@"</span>, x , [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"finishi!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：<br><img src="http://i2.buimg.com/572363/a0cc83549bcc31a1.png" alt="Markdown"></p>
<p>有趣的信息很多，我们可以看到每个任务完成的顺序并不一定，而且所在的线程也不一定。(<code>number</code>不为1的话都是子线程)在所有任务都完成后，才会打印<code>finish</code>。</p>
<p>这是因为<code>dispatch_apply</code>函数会阻塞住当前线程，这和<code>dispatch_sync</code>是一样的。所以推荐在<code>dispath_async</code>函数中异步地执行<code>dispatch_apply</code>函数。当然了，关于队列的选择上肯定也要是并发队列，否则没有任何意义:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        dispatch_apply(<span class="number">10</span>, queue, ^(size_t x) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%zu current thead == %@"</span>, x , [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"finish %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line"></div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，在<a href="https://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2" target="_blank" rel="external">这篇文章</a>中作者也提到了：使用<code>dispatch_apply</code>函数开辟线程来执行任务可能要比<code>for</code>循环代价大得多，所以使用前要三思。</p>
<h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 | Semaphore"></a>信号量 | Semaphore</h2><h3 id="有趣的哲学家问题"><a href="#有趣的哲学家问题" class="headerlink" title="有趣的哲学家问题"></a>有趣的哲学家问题</h3><p>在了解信号量之前，可以先看看这个有趣的问题：<a href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98" target="_blank" rel="external">哲学家就餐问题</a>。</p>
<p>以下摘自维基百科：</p>
<blockquote>
<p>信号量（英语：Semaphore）又称为信号量、旗语，它以一个整数变量，提供信号，以确保在并行计算环境中，不同进程在访问共享资源时，不会发生冲突。是一种不需要使用忙碌等待（busy waiting）的一种方法。</p>
<p>信号量的概念是由荷兰计算机科学家艾兹格·迪杰斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系中，二进制信号量（binary semaphore）又称Mutex。</p>
</blockquote>
<h3 id="一个错误的例子"><a href="#一个错误的例子" class="headerlink" title="一个错误的例子"></a>一个错误的例子</h3><p>回到我们的代码中，在上一篇<a href="http://objc.in/2016/08/24/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%87%8D%E6%B8%A9GCD%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">iOS中的多线程编程：重温GCD（一）</a>中我曾介绍过：<code>NSMutableArray</code>不是线程安全的，所以以下的写法会有很大的问题：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableArray</span> *array  = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    </div><div class="line">    _array = array;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span>;  i ++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">                [_array addObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%d"</span>,i]];</div><div class="line">                </div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以试试运行上述代码，很容易引发crash。此时就可以使用 Dispatch Semaphore 来避免这个问题。</p>
<h3 id="利用-Dispatch-Semaphore-来解决"><a href="#利用-Dispatch-Semaphore-来解决" class="headerlink" title="利用 Dispatch Semaphore 来解决"></a>利用 Dispatch Semaphore 来解决</h3><p>摘自：<strong>《objc高级编程：iOS 与 OS X 多线程与内存管理》</strong>：</p>
<blockquote>
<p>Dispatch Semaphore 是持有计数的信号，该计数是多线程编程中的计数类型信号。所谓信号，是类似于过马路时常用的手旗，可以通过时举起手旗，不可通过时放下手旗。而在 Dispatch Semaphore 中，使用计数来实现此功能。计数为0时等待，计数为1或者大于1时，减去1而不等待。</p>
</blockquote>
<p>### </p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>请杯咖啡喝？</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://i1.buimg.com/572363/b21593e5f65ea204.jpg" alt="Zheng Li WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="http://i1.buimg.com/572363/7caac38df4844f66.jpg" alt="Zheng Li Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/24/iOS中的多线程编程：重温GCD（一）/" rel="next" title="iOS中的多线程编程：重温GCD（一）">
                <i class="fa fa-chevron-left"></i> iOS中的多线程编程：重温GCD（一）
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/27/IP-TCP和HTTP/" rel="prev" title=" [面试] IP , TCP 和 HTTP ">
                 [面试] IP , TCP 和 HTTP  <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/08/26/iOS中的多线程编程：重温GCD（二）/"
           data-title="iOS中的多线程编程：重温GCD（二）" data-url="http://yoursite.com/2016/08/26/iOS中的多线程编程：重温GCD（二）/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://tva3.sinaimg.cn/crop.0.0.511.511.180/006pqpL6jw8f4z97xky5nj30e70e8aai.jpg"
               alt="Zheng Li" />
          <p class="site-author-name" itemprop="name">Zheng Li</p>
          <p class="site-description motion-element" itemprop="description">iOS开发菜鸡，努力提高自我中。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://yulingtianxia.com/" title="yulingtianxia" target="_blank">yulingtianxia</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://kyxu.tech/" title="kyXu" target="_blank">kyXu</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栅栏-Using-Barriers"><span class="nav-number">2.</span> <span class="nav-text">栅栏 | Using Barriers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用barrier构建一个安全的读写操作"><span class="nav-number">2.1.</span> <span class="nav-text">使用barrier构建一个安全的读写操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#barrier的API"><span class="nav-number">2.2.</span> <span class="nav-text">barrier的API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#barrier使用建议"><span class="nav-number">2.3.</span> <span class="nav-text">barrier使用建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#barrier部分小结"><span class="nav-number">2.4.</span> <span class="nav-text">barrier部分小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度组-Dispatch-Groups"><span class="nav-number">3.</span> <span class="nav-text">调度组 | Dispatch Groups</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Dispatch-Groups通知所有任务已经完成"><span class="nav-number">3.1.</span> <span class="nav-text">使用Dispatch Groups通知所有任务已经完成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法一：使用dispatch-group-notify"><span class="nav-number">3.1.1.</span> <span class="nav-text">方法一：使用dispatch_group_notify</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法二：使用dispatch-group-wait"><span class="nav-number">3.1.2.</span> <span class="nav-text">方法二：使用dispatch_group_wait</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并行运行的for循环：dispatch-apply"><span class="nav-number">4.</span> <span class="nav-text">并行运行的for循环：dispatch_apply</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量-Semaphore"><span class="nav-number">5.</span> <span class="nav-text">信号量 | Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有趣的哲学家问题"><span class="nav-number">5.1.</span> <span class="nav-text">有趣的哲学家问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个错误的例子"><span class="nav-number">5.2.</span> <span class="nav-text">一个错误的例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用-Dispatch-Semaphore-来解决"><span class="nav-number">5.3.</span> <span class="nav-text">利用 Dispatch Semaphore 来解决</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Li</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"BJTUzhengli"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("28Bi52ufQCnrlpfv4vbx8JEG-gzGzoHsz", "1cAbB9JCSijqEURfv3Pa9uYd");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
